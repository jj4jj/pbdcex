#ifndef __PBDCEX_H_DEF_{{file_name|unif}}__
#define __PBDCEX_H_DEF_{{file_name|unif}}__
#pragma once
//This file is auto generated by pbdcex [http://github.com/jj4jj/pbdcex.git],
//Please do NOT edit it ! Any bug please let jj4jj known .
//File generated time: {{time}}

{{!for vd in depencies}}
#include "{{vd}}"
{{}}
#include "pbdcex.core.hpp"
{{ns_begin}}
using pbdcex::string_t;
using pbdcex::bytes_t;
using pbdcex::array_t;
using pbdcex::serializable_t;
{{!for vmsg in msgs}}
struct {{vmsg.meta|cs.msg.name}} : public serializable_t<{{vmsg.meta|cs.msg.name}}, {{vmsg.meta|msg.name}}> {
    {{!for vf in vmsg.fields}}{{vf.meta|cs.field.wtype}}       {{vf.meta|cs.field.name}};
    {{}}////////////////////////////////////////////////////////////////////////
    void    construct(){
        if(sizeof(*this) < 1024){
            memset(this, 0, sizeof(*this));
        }
        else {
            {{!for vf in vmsg.fields}}
            {{!if vf.meta|field.is_array}}
            {{vf.meta|cs.field.name}}.construct();
            {{!elif vf.meta|field.is_num}}
            {{vf.meta|cs.field.name}}=static_cast<{{vf.meta|cs.field.type}}>(0);
            {{!elif vf.meta|field.is_bool}}
            {{vf.meta|cs.field.name}}=false;
            {{!else}}
            {{vf.meta|cs.field.name}}.construct();
            {{}}
            {{}}
        }
    }
    int     convto({{vmsg.meta|msg.name}} & tomsg_) const {
        int ret = 0;
        tomsg_.Clear();
        {{!for vf in vmsg.fields}}
        {{!if vf.meta|field.is_array}}
        for (size_t i = 0;i < {{vf.meta|field.name}}.count; ++i){
            {{!if vf.meta|field.is_msg}}
            ret = this->{{vf.meta|cs.field.name}}.list[i].convto(*tomsg_.add_{{vf.meta|field.name}}());
            if (ret){return __LINE__+ret;}
            {{!elif vf.meta|field.is_bytes }}
            tomsg_.add_{{vf.meta|field.name}}(this->{{vf.meta|cs.field.name}}.list[i].data, this->{{vf.meta|cs.field.name}}.list[i].length);
            {{!elif vf.meta|field.is_string }}
            tomsg_.add_{{vf.meta|field.name}}(this->{{vf.meta|cs.field.name}}.list[i].data);
            {{!else}}
            tomsg_.add_{{vf.meta|field.name}}(this->{{vf.meta|cs.field.name}}.list[i]);
            {{}}}
        {{!else}}
        {{!if vf.meta|field.is_msg}}
        ret = this->{{vf.meta|cs.field.name}}.convto(*tomsg_.mutable_{{vf.meta|field.name}}());
        if (ret) {return __LINE__+ret;}
        {{!elif vf.meta|field.is_bytes}}
        tomsg_.set_{{vf.meta|field.name}}(this->{{vf.meta|cs.field.name}}.data, this->{{vf.meta|cs.field.name}}.length);
        {{!elif vf.meta|field.is_string}}
        tomsg_.set_{{vf.meta|field.name}}(this->{{vf.meta|cs.field.name}}.data);
        {{!else}}tomsg_.set_{{vf.meta|field.name}}(this->{{vf.meta|cs.field.name}});
        {{}}
        {{}}
        {{}}
        return ret;
    }
    int     convfrom(const {{vmsg.meta|msg.name}} & frommsg_) {
		int ret = 0;
        {{!for vf in vmsg.fields}}
        {{!if vf.meta|field.is_array}}
        this->{{vf.meta|cs.field.name}}.count=0;
        for (size_t i = 0; i < (size_t)frommsg_.{{ vf.meta | field.name }}_size() && i < {{ vf.meta | field.count }}; ++i, ++(this->{{ vf.meta | cs.field.name }}.count)){
            {{!if vf.meta|field.is_msg}}
            ret = this->{{vf.meta|cs.field.name}}.list[i].convfrom(frommsg_.{{vf.meta|field.name}}(i));
            if (ret) {return __LINE__+ret;}
            {{!elif vf.meta|field.is_bytes}}
            assert(frommsg_.{{vf.meta|field.name}}(i).length() <= {{vf.meta|field.length}});
            this->{{ vf.meta | cs.field.name }}.list[i].assign(frommsg_.{{ vf.meta | field.name }}(i));
            {{ !elif vf.meta | field.is_string }}
            assert(frommsg_.{{ vf.meta | field.name }}(i).length() < {{ vf.meta | field.length }});
            this->{{ vf.meta | cs.field.name }}.list[i].assign(frommsg_.{{ vf.meta | field.name }}(i).data());
            {{!else}}
            this->{{vf.meta|cs.field.name}}.list[i] = frommsg_.{{vf.meta|field.name}}(i);
            {{}}
        }
        {{!else}}
        {{!if vf.meta|field.is_msg}}
        ret = this->{{vf.meta|cs.field.name}}.convfrom(frommsg_.{{vf.meta|field.name}}());
        if (ret) {return __LINE__+ret;}
        {{ !elif vf.meta | field.is_bytes }}
        assert(frommsg_.{{ vf.meta | field.name }}().length() <= {{ vf.meta | field.length }});
        this->{{vf.meta|cs.field.name}}.assign(frommsg_.{{vf.meta|field.name}}());
        {{ !elif vf.meta | field.is_string }}
        assert(frommsg_.{{ vf.meta | field.name }}().length() < {{ vf.meta | field.length }});
        this->{{vf.meta|cs.field.name}}.assign(frommsg_.{{vf.meta|field.name}}().data());
        {{!else}}
        this->{{vf.meta|cs.field.name}} = frommsg_.{{vf.meta|field.name}}();
        {{}}
        {{}}
        {{}}
        return ret;
    }
	void     diff(const {{ vmsg.meta | cs.msg.name }} & orgv , {{ vmsg.meta | msg.name }} & updates, {{ vmsg.meta | msg.name }} & removes) const {
		{{!for vf in vmsg.pkfields}}
		{{!if vf.meta | field.is_array }}
		{
			decltype(this->{{vf.meta | cs.field.name}}.count) i = 0, j = 0;
			while(i <= this->{{vf.meta | cs.field.name}}.count || j < orgv.{{vf.meta | cs.field.name}}.count){
				if(i <= this->{{vf.meta | cs.field.name}}.count && j < orgv.{{vf.meta | cs.field.name}}.count &&
					this->{{vf.meta | cs.field.name}}.list[i] == this->{{vf.meta | cs.field.name}}.list[j]){
					auto upd = updates.mutable_{{ vf.meta | field.name }}()->Add();
					{{!if vf.meta | field.is_msg }}						
					auto rem = updates.mutable_{{ vf.meta | field.name }}()->Add();
					this->{{vf.meta | cs.field.name}}.list[i].diff(this->{{vf.meta | cs.field.name}}.list[j],*upd,*rem);
					{{!elif vf.meta | field.is_string }}
					*upd = this->{{vf.meta | cs.field.name}}.list[i].data;
					{{!elif vf.meta | field.is_bytes }}
					upd->assign((const char*)this->{{vf.meta | cs.field.name}}.list[i].data, this->{{vf.meta | cs.field.name}}.list[i].length);
					{{!else}}
					*upd = this->{{vf.meta | cs.field.name}}.list[i];
					{{}}
					++i; ++j;
				}
				else if (i < this->{{vf.meta | cs.field.name}}.count) {
					auto upd = updates.mutable_{{ vf.meta | field.name }}()->Add();
					{{!if vf.meta | field.is_msg }}
					this->{{vf.meta | cs.field.name}}.list[i].convto(*upd);
					{{!elif vf.meta | field.is_string }}
					*upd = this->{{vf.meta | cs.field.name}}.list[i].data;
					{{!elif vf.meta | field.is_bytes }}
					upd->assign((const char*)this->{{vf.meta | cs.field.name}}.list[i].data, this->{{vf.meta | cs.field.name}}.list[i].length);
					{{!else}}
					*upd = this->{{vf.meta | cs.field.name}}.list[i];
					{{}}
					++i;
				}
				else {
					auto rem = removes.mutable_{{ vf.meta | field.name }}()->Add();
					{{!if vf.meta | field.is_msg }}
					this->{{vf.meta | cs.field.name}}.list[i].convto(*rem);
					{{!elif vf.meta | field.is_string }}
					*rem = this->{{vf.meta | cs.field.name}}.list[j].data;
					{{!elif vf.meta | field.is_bytes }}
					rem->assign((const char*)this->{{vf.meta | cs.field.name}}.list[j].data, this->{{vf.meta | cs.field.name}}.list[j].length);
					{{!else}}
					*rem = this->{{vf.meta | cs.field.name}}.list[j];
					{{}}
					++j;
				}
			}
		}
		{{!elif vf.meta | field.is_msg}}
		this->{{vf.meta | cs.field.name}}.diff(orgv.{{vf.meta | cs.field.name}}, *updates.mutable_{{ vf.meta | cs.field.name }}(), *removes.mutable_{{ vf.meta | cs.field.name }}());
		{{!else}}
		if (!(this->{{vf.meta | cs.field.name}} == orgv.{{vf.meta | cs.field.name}})) {
			{{!if vf.meta | field.is_string }}
			updates.set_{{ vf.meta | field.name }}(this->{{ vf.meta | cs.field.name }}.data);
			{{!elif vf.meta | field.is_bytes}}
			updates.set_{{ vf.meta | field.name }}((char*)this->{{ vf.meta | cs.field.name }}.data, this->{{ vf.meta | cs.field.name }}.length);
			{{!else}}
			updates.set_{{ vf.meta | field.name }}(this->{{ vf.meta | cs.field.name }});
			{{}}
		}
		{{}}
		{{}}
	}
    int     compare(const {{vmsg.meta|cs.msg.name}} & rhs_) const {
        int cmp = 0;
        {{!for vf in vmsg.pkfields}}
        {{!if vf.meta|field.is_array}}
        cmp = this->{{vf.meta|cs.field.name}}.compare(rhs_.{{vf.meta|cs.field.name}});
        if(cmp){return cmp;}
        {{!elif vf.meta|field.is_msg}}
        cmp = this->{{vf.meta|cs.field.name}}.compare(rhs_.{{vf.meta|cs.field.name}});
        if(cmp){return cmp;}
        {{!else}}
        if (this->{{vf.meta|cs.field.name}} < rhs_.{{vf.meta|cs.field.name}}){
            return -1;
        }
        else if(this->{{vf.meta|cs.field.name}} > rhs_.{{vf.meta|cs.field.name}}){
            return 1;
        }
        {{}}
        {{}}
        return cmp;
    }
    bool    operator == (const {{vmsg.meta|cs.msg.name}} & rhs_) const {
        return this->compare(rhs_) == 0;
    }
    bool    operator < (const {{vmsg.meta|cs.msg.name}} & rhs_) const {
        return this->compare(rhs_) < 0;
    }
    size_t hash() const {
        {{!if vmsg.pkfields_num < 2}}
        {{!for vf in vmsg.pkfields}}
        {{!if vf.meta|field.is_array}}
        return this->{{vf.meta|cs.field.name}}.hash();
        {{!elif vf.meta|field.is_num}}
        return (size_t)(this->{{vf.meta|cs.field.name}});
        {{!else}}
        return this->{{vf.meta|cs.field.name}}.hash();
        {{}}
        {{}}
        {{!else}}
        size_t avhs[] = {
        {{!for vf in vmsg.pkfields}}
        {{!if vf.meta|field.is_array}}
             this->{{vf.meta|cs.field.name}}.hash(),
        {{!elif vf.meta|field.is_num}}
            (size_t)(this->{{vf.meta|cs.field.name}}),
        {{!else}}
            this->{{vf.meta|cs.field.name}}.hash(),
        {{}}
        {{}}
        };
        return pbdcex::hash_code_merge_multi_value(avhs, {{vmsg.pkfields_num}});
        {{}}
    }
};
{{}}
{{ns_end}}
#endif
