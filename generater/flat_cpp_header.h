#pragma once
#include "ext_meta.h"
#include "google/protobuf/compiler/importer.h"
#include <iostream>
#include <fstream>
#include "cxxtemplates/xctmp.h"

extern std::stringstream error_stream;
using namespace std;
using namespace google::protobuf;

extern std::stringstream error_stream;

/*
for msg in pb.msgs

    struct msg.name | cs.msg_type_name {
        for field in msg.fields
            field.type | cs.field_type  field.name | cs.field_name;
        void    construct(){
            memset(this, 0, sizeof(*this));
        }
        int     convto(msg.type & tomsg_) const {
            int ret = 0;
            for field in msg.fields
                if field.count > 0
                    for (int i = 0;i < field.name .count; ++i){
                        if field.type | pb.is_msg = 1
                            ret += field.name[i].convto(*tomsg_.add_field.name);
                            if (ret) return __LINE__+ret;
                        elif field.type | pb.is_bytes = 1
                            tomsg_.add_field.name(field.name[i].data, field.name[i].length);
                        elif field.type | pb.is_string = 1
                            tomsg_.add_field.name(field.name[i].data);
                        else
                            tomsg_.add_field.name(field.name[i]);
                    }
                else
                    if field.type | pb.is_msg = 1
                        ret += field.name|cs.field_name.convto(*tomsg_.mutable_field.name);
                        if (ret) return ret;
                    elif field.type | pb.is_bytes = 1
                        tomsg_.set_field.name(field.name[i].data, field.name[i].length);
                    elif field.type | pb.is_string = 1
                        tomsg_.set_field.name(field.name[i].data);
                    else
                        tomsg_.set_field.name(field.name[i]);
                return ret;
        }
        int     convfrom() const {
            int ret = 0;
            for field in msg.fields
            if field.count > 0
            for (int i = 0;i < field.name .count; ++i){
            if field.type | pb.is_msg = 1
            ret += field.name[i].convto(*tomsg_.add_field.name);
            if (ret) return ret;
            elif field.type | pb.is_bytes = 1
            tomsg_.add_field.name(field.name[i].data, field.name[i].length);
            elif field.type | pb.is_string = 1
            tomsg_.add_field.name(field.name[i].data);
            else
            tomsg_.add_field.name(field.name[i]);
            }
            else
            if field.type | pb.is_msg = 1
            ret += field.name|cs.field_name.convto(*tomsg_.mutable_field.name);
            if (ret) return ret;
            elif field.type | pb.is_bytes = 1
            tomsg_.set_field.name(field.name[i].data, field.name[i].length);
            elif field.type | pb.is_string = 1
            tomsg_.set_field.name(field.name[i].data);
            else
            tomsg_.set_field.name(field.name[i]);
            return ret;
        }
        int     compare(const msg.name | cs.msg_type_name & rhs_) const {
            int cmp = 0;
            for field in msg.fields
                cmp = field.name|cs.filed_name.compare(rhs_.field.name);
                if cmp return cmp;
            return 0;
        }
        bool    operator == (const msg.name | cs.msg_type_name & rhs_) const {
            return this->compare(rhs_) == 0;
        }
        bool    operator < (const msg.name | cs.msg_type_name & rhs_) const {
            return this->compare(rhs_) < 0;
        }

    }
*/


class CXXFlatMsgGenerater {
    typedef std::unordered_map<const Descriptor *, int>										MsgDegree;
    typedef	std::unordered_map<const Descriptor *, std::unordered_set<const Descriptor *> >	ReverseRef;
    typedef ReverseRef::iterator	ReverseRefItr;

    ReverseRef	reverse_refer;
    MsgDegree	msg_degrees;
    const Descriptor * root;
    std::vector<const Descriptor*>	ordered_desc;
public:
    CXXFlatMsgGenerater(const Descriptor * desc){
        root = desc;
    }
    void	DumpFile(const char * file){
        ofstream ofs(file, ios::out);
        ofs << GetCodeText() << endl;
    }
    string	GetCodeText(){
        TopologySort(ordered_desc);
        std::stringstream oss;

        oss << "#pragma once" << endl << endl;
        oss << "//this file is auto generated by (hbpex)[https://github.com/jj4jj/hpbex.git] , don't edit this file !" << endl;
        time_t t_m = time(NULL);
        oss << "//file generate datetime: " << asctime(localtime(&t_m)) << endl;

        const string proto_name_post_fix = ".proto";
        string this_proto_heder_file_name = root->file()->name();
        this_proto_heder_file_name.replace(this_proto_heder_file_name.find(proto_name_post_fix), proto_name_post_fix.length(), ".pb.h");
        //import default
        oss << "#include \"pbdcex.core.hpp\"" << endl;
        //import
        for (int i = 0; i < root->file()->dependency_count(); ++i){
            auto f = root->file()->dependency(i);
            string ns_name = f->name();
            if (ns_name == "extensions.proto"){
                continue;
            }
            ns_name.replace(ns_name.find(proto_name_post_fix), proto_name_post_fix.length(), ".hpb.h");
            oss << "#include \"" << ns_name << "\"" << endl;
        }

        //self proto .pb.h
        oss << "#include \"" << this_proto_heder_file_name << "\"" << endl;
        oss << endl;

        //package begin
        if (!root->file()->package().empty()){
            oss << "namespace " << root->file()->package() << " { " << endl;
        }
        oss << endl;
        //declaration using
        for (int i = 0; i < (int)ordered_desc.size(); ++i){
            string ns_name = ordered_desc[i]->file()->package();
            if (!ns_name.empty() && ns_name != root->file()->package()){
                //oss << "using " << ns_name << "::" << ordered_desc[i]->name() << endl;
                oss << "using " << ns_name << "::" << EXTMetaUtil::GetStructName(ordered_desc[i]) << ";" << endl;
            }
        }
        oss << endl;

        //convert
        for (int i = 0; i < (int)ordered_desc.size(); ++i){
            oss << ConvertMsg(ordered_desc[i]);
        }
        oss << endl;

        //package end
        if (!root->file()->package().empty()){
            oss << "} // end of namespace: " << root->file()->package() << endl;
        }
        return oss.str();
    }
    string	ConvertMsg(const Descriptor * desc, const char * indent = "    "){
 
        ifstream ifs("cxx.tmp", ios::in);
        char cxxbuffer[4098];
        ifs.getline(cxxbuffer, 4098, 0);
        
        xctmp_t * xc = xctmp_parse(cxxbuffer);
        if (!xc){
            cerr << "xctmp parse errror !" << endl;
            return "";
        }
        //cs.msg.name <- meta
        //cs.field.name <- meta
        xctmp_push_filter(xc, "cs_msg_name", [](const string & p)->string {
            EXTMessageMeta * m = (EXTMessageMeta*)(strtoull(p.c_str(), NULL, 16));
            return m->msg_desc->name() + "_ST";
        });
        xctmp_push_filter(xc, "cs_field_type", [](const string & p)->string {
            EXTFieldMeta * m = (EXTFieldMeta*)(strtoull(p.c_str(), NULL, 16));
            cerr << "field_name:" << p << endl;
            return m->GetTypeName();
        });

        xctmp_push_filter(xc, "cs_field_name", [](const string & p)->string {
            EXTFieldMeta * m = (EXTFieldMeta*)(strtoull(p.c_str(), NULL, 16));
            cerr << "field_name:" << p << endl;
            return m->GetVarName();
        });
        xctmp_push_filter(xc, "msg_name", [](const string & p)->string {
            EXTMessageMeta * m = (EXTMessageMeta*)(strtoull(p.c_str(), NULL, 16));
            return m->msg_desc->name();
        });
        xctmp_push_filter(xc, "field_is_msg", [](const string & p)->string {
            EXTFieldMeta * m = (EXTFieldMeta*)(strtoull(p.c_str(), NULL, 16));
            return m->field_desc->message_type() ? "1" : "0";
        });
        xctmp_push_filter(xc, "field_is_string", [](const string & p)->string {
            EXTFieldMeta * m = (EXTFieldMeta*)(strtoull(p.c_str(), NULL, 16));
            return m->field_desc->type() == google::protobuf::FieldDescriptor::TYPE_STRING ? "1" : "0";
        });
        xctmp_push_filter(xc, "field_is_bytes", [](const string & p)->string {
            EXTFieldMeta * m = (EXTFieldMeta*)(strtoull(p.c_str(), NULL, 16));
            return m->field_desc->type() == google::protobuf::FieldDescriptor::TYPE_BYTES ? "1" : "0";
        });
        xctmp_push_filter(xc, "field_count", [](const string & p)->string {
            EXTFieldMeta * m = (EXTFieldMeta*)(strtoull(p.c_str(), NULL, 16));
            return to_string(m->z_count);
        });
        xctmp_push_filter(xc, "field_length", [](const string & p)->string {
            EXTFieldMeta * m = (EXTFieldMeta*)(strtoull(p.c_str(), NULL, 16));
            return to_string(m->z_length);
        });

        //cs.msg.name <- meta
        //cs.field.type <- meta
        //cs.field.name <- meta
        //msg.type
        //msg.name
        //field.is_msg
        //field.is_string
        //field.is_bytes
        //field.is_ui32
        //field.is_ui64
        //field.is_i32
        //field.is_i64
        //field.is_fixed64
        //field.is_float
        //field.is_double
        //field.count
        //field.length
        //field.msg
        //field.is_pk
        EXTMessageMeta	msg_meta;
        if (msg_meta.AttachDesc(desc)){
            throw logic_error("parse error !");
        }
        char cvbuff[64];
        string output;
        string jenv = "{\
        \"meta\":";
        snprintf(cvbuff, sizeof(cvbuff), "\"%p\"", &msg_meta);
        jenv += cvbuff;
        jenv += ",\"fields\":[";
        bool head = true;
        for (auto & sfm : msg_meta.sub_fields){
            if (!head){
                jenv += ",";
            }
            snprintf(cvbuff, sizeof(cvbuff), "\"%p\"", &sfm);
            jenv += "{\"meta\":";
            jenv += cvbuff;
            jenv += "}";
            head = false;
        }
        jenv += "]}";
        cout << jenv << endl;       
        xctmp_render(xc, output, jenv);        
        xctmp_destroy(xc);
        return output;
#if 0        
        stringstream ss_convert_msg;
        int level = 0;
        char sz_line_buffer[1024];
#define	WRITE_LINE(format, ...)		do{\
    snprintf(sz_line_buffer, sizeof(sz_line_buffer), format, ##__VA_ARGS__); \
    ss_convert_msg << CXXFlatMsgGenerater::repeat(indent, level) << sz_line_buffer << std::endl; \
        }while (false)
#define	WRITE_STR(format, ...)		do{\
    snprintf(sz_line_buffer, sizeof(sz_line_buffer), format, ##__VA_ARGS__); \
    ss_convert_msg << CXXFlatMsgGenerater::repeat(indent, level) << sz_line_buffer; \
        }while (false)
        ////////////////////////////////////////////////////////////////////////////////////
        if (desc->file()->package() != root->file()->package()){
            return "";
            //WRITE_LINE("using %s::%s;", desc->file()->package().c_str(), EXTMetaUtil::GetStructName(desc).c_str());
            //return ss_convert_msg.str();
        }

        //struct Msg {
        WRITE_LINE("struct %s {", EXTMetaUtil::GetStructName(desc).c_str());
        level++;
        std::vector<EXTFieldMeta>	fieldmeta_list;

        EXTMessageMeta	msg_meta;
        if (msg_meta.AttachDesc(desc)){
            throw logic_error("parse error !");
        }

        for (auto & sfm : msg_meta.sub_fields){
            if (sfm.f_count.empty()){
                WRITE_LINE("%s\t\t%s;", sfm.GetTypeName().c_str(), sfm.GetVarName().c_str());
            }
            else {
                WRITE_LINE("pbdcex::array_t<%s,%s>\t\t%s;",
                    sfm.GetTypeName().c_str(), sfm.f_count.c_str(), sfm.GetVarName().c_str());
            }
            fieldmeta_list.push_back(sfm);
        }
        ///////////////////////////////////////////////////////////////////////////
        WRITE_LINE("\t");
        WRITE_LINE("//////////////member functions///////////////////////////////////");
        //construct
        WRITE_LINE("void\t\tconstruct() {");
        ++level;
        WRITE_LINE("if(sizeof(*this) < 1024) { memset(this,0,sizeof(*this)); return ;}");
        for (auto & sfm : msg_meta.sub_fields){
            //set
            string st_var_name = sfm.GetVarName();
            if (!sfm.f_count.empty()){
                WRITE_LINE("%s.count = 0U;", st_var_name.c_str());
            }
            else {
                if (sfm.field_desc->type() == FieldDescriptor::TYPE_STRING){
                    WRITE_LINE("%s.data[0] = 0;", st_var_name.c_str());
                }
                else if (sfm.field_desc->type() == FieldDescriptor::TYPE_BYTES){
                    WRITE_LINE("%s.length = 0U;", st_var_name.c_str());
                }
                else if (sfm.field_desc->type() == FieldDescriptor::TYPE_ENUM){
                    WRITE_LINE("%s = %s;//should be 0", st_var_name.c_str(),
                        sfm.field_desc->default_value_enum()->name().c_str());
                    if (sfm.field_desc->default_value_enum()->number() != 0){
                        WRITE_LINE("#warning \"enum type:%s default value should be 0 value define but %s != 0 \"",
                            sfm.field_desc->default_value_enum()->type()->name().c_str(),
                            sfm.field_desc->default_value_enum()->name().c_str());
                        WRITE_LINE("assert( \"enum default value should be 0 value define !\" && %s == 0 );",
                            sfm.field_desc->default_value_enum()->name().c_str());
                    }
                }
                else if (sfm.field_desc->cpp_type() == FieldDescriptor::CPPTYPE_MESSAGE){
                    WRITE_LINE("%s.construct();", st_var_name.c_str());
                }
                else {// (sfm.field_desc->cpp_type() <= FieldDescriptor::CPPTYPE_ENUM)
                    WRITE_LINE("%s = 0;", st_var_name.c_str());
                }
            }
        }
        --level;
        WRITE_LINE("}");
        //if memset()

        ///////////////////////////////////////////////////////////////////////////
        //convto
        WRITE_LINE("void\t\tconvto(%s & convtomsg_) const {", desc->name().c_str());
        ++level;
        for (auto & sfm : msg_meta.sub_fields){
            //set
            string st_var_name = sfm.GetVarName();
            if (!sfm.f_count.empty()){
                WRITE_LINE("assert(%s.count <= %s);//assertion", st_var_name.c_str(), sfm.f_count.c_str());
                //for(size_t i = 0;i < a.count; ++i)
                WRITE_LINE("for ( size_t i = 0; i < %s.count && i < (sizeof(%s.list)/sizeof(%s.list[0])); ++i){",
                    st_var_name.c_str(), st_var_name.c_str(), st_var_name.c_str());
                st_var_name += ".list[i]";
                ++level;
            }
            WRITE_LINE("%s;", sfm.GetScalarConvToMeth("convtomsg_", st_var_name, sfm.field_desc->name()).c_str());
            if (!sfm.f_count.empty()){
                --level;
                WRITE_LINE("}");
            }
        }
        --level;
        WRITE_LINE("}");
        ///////////////////////////////////////////////////////////////////////////
        //convto
        WRITE_LINE("void\t\tconvfrom(const %s & convfrommsg_) {", desc->name().c_str());
        ++level;
        for (auto & sfm : msg_meta.sub_fields){
            //set
            string st_var_name = sfm.GetVarName();
            string msg_var_name = sfm.field_desc->name();
            if (!sfm.f_count.empty()){
                WRITE_LINE("assert(convfrommsg_.%s_size() <= %s);//assertion", msg_var_name.c_str(), sfm.f_count.c_str());
                //for(size_t i = 0;i < a.count; ++i)
                WRITE_LINE("%s.count = 0;", sfm.GetVarName().c_str());
                WRITE_LINE("for ( size_t i = 0; i < (size_t)convfrommsg_.%s_size() && i < (sizeof(%s.list)/sizeof(%s.list[0])); ++i){", msg_var_name.c_str(), msg_var_name.c_str(), msg_var_name.c_str());
                st_var_name += ".list[i]";
                msg_var_name += "(i)";
                ++level;
            }
            else {
                msg_var_name += "()";
            }
            WRITE_LINE("%s;", sfm.GetScalarConvFromMeth("convfrommsg_", st_var_name, msg_var_name.c_str()).c_str());
            if (!sfm.f_count.empty()){
                WRITE_LINE("++%s.count;", sfm.GetVarName().c_str());
                --level;
                WRITE_LINE("}");
            }
        }
        --level;
        WRITE_LINE("}");
        ///////////////////////////////////////////////////////////////////////////////
        //int compare
        WRITE_LINE("int\t\tcompare(const %s & rhs_) const {", EXTMetaUtil::GetStructName(desc).c_str());
        ++level;
        WRITE_LINE("int _cmp_ret = 0;");
        //
        string var_name;
        for (size_t i = 0; i < msg_meta.pks_fields.size(); ++i){
            auto & sfm = *msg_meta.pks_fields[i];
            var_name = sfm.GetVarName();
            if (!sfm.f_count.empty()){
                WRITE_LINE("for (size_t i = 0; i < %s.count && i < rhs_.%s.count; ++i) {",
                    sfm.GetVarName().c_str(), sfm.GetVarName().c_str());
                var_name += ".list[i]";
                ++level;
            }
            if (sfm.field_desc->type() == FieldDescriptor::TYPE_FLOAT ||
                sfm.field_desc->type() == FieldDescriptor::TYPE_DOUBLE){
                WRITE_LINE("#warning \"%s\";", "comparing variable is a float number , maybe not precise .");
                WRITE_LINE("_cmp_ret = ((%s + 10e-6) < rhs_.%s) ? -1 : (%s > (rhs_.%s + 10e-6) ? 1 : 0);",
                    var_name.c_str(), var_name.c_str(),
                    var_name.c_str(), var_name.c_str());
            }
            else if (sfm.field_desc->type() == FieldDescriptor::TYPE_STRING){
                WRITE_LINE("_cmp_ret = strncmp(%s.data, rhs_.%s.data, %s);",
                    var_name.c_str(), var_name.c_str(),
                    sfm.f_length.c_str());
            }
            else if (sfm.field_desc->type() == FieldDescriptor::TYPE_BYTES){
                WRITE_LINE("_cmp_ret = memcmp(%s.data, rhs_.%s.data, std::min(%s.length, rhs_%s.length));",
                    var_name.c_str(), var_name.c_str(),
                    var_name.c_str(), var_name.c_str());
                WRITE_LINE("if (_cmp_ret == 0) { _cmp_ret = (%s.length < rhs_%s.length) ? -1 : ((%s.length == rhs_%s.length): 0: 1); }",
                    var_name.c_str(), var_name.c_str(),
                    var_name.c_str(), var_name.c_str());
            }
            else if (sfm.field_desc->type() == FieldDescriptor::TYPE_MESSAGE){
                WRITE_LINE("_cmp_ret = %s.compare(rhs_.%s);",
                    var_name.c_str(), var_name.c_str());
            }
            else {
                WRITE_LINE("_cmp_ret = (%s < rhs_.%s) ? -1 : ((%s == rhs_.%s) ? 0 : 1);",
                    var_name.c_str(), var_name.c_str(),
                    var_name.c_str(), var_name.c_str());
            }
            WRITE_LINE("if (_cmp_ret != 0) { return _cmp_ret; }");
            if (!sfm.f_count.empty()){
                //end for(size_t i = 0 ;i < count ; ++i){
                --level;
                WRITE_LINE("}");
                WRITE_LINE("_cmp_ret = (%s.count < rhs_.%s.count ) ? -1 : ((%s.count == rhs_.%s.count ) ? 0 : 1);",
                    sfm.GetVarName().c_str(), sfm.GetVarName().c_str(),
                    sfm.GetVarName().c_str(), sfm.GetVarName().c_str());
            }
        }
        WRITE_LINE("return 0;");
        --level;
        WRITE_LINE("}");

        //bool operator ==  //for find
        WRITE_LINE("bool\t\toperator == (const %s & rhs_) const {", EXTMetaUtil::GetStructName(desc).c_str());
        ++level;
        WRITE_LINE("return this->compare(rhs_) == 0;");
        --level;
        WRITE_LINE("}");

        //bool operator <  //for less //////////////////////////////////////////
        WRITE_LINE("bool\t\toperator < (const %s & rhs_) const {", EXTMetaUtil::GetStructName(desc).c_str());
        ++level;
        WRITE_LINE("return this->compare(rhs_) < 0;");
        --level;
        WRITE_LINE("}");

        ///////////////////////////////////////////////////////////////////////////////
        level--;
        WRITE_LINE("};");
        return ss_convert_msg.str();
#endif
    }
    void	TopologySort(std::vector<const Descriptor * > & msgs){
        msgs.clear();
        std::queue<const Descriptor *>  desc_queue;
        desc_queue.push(root);
        msg_degrees[root] = 0;
        while (!desc_queue.empty()){
            auto msg = desc_queue.front();
            desc_queue.pop();
            for (int i = 0; i < msg->field_count(); ++i){
                auto field_def = msg->field(i);
                if (field_def->type() == FieldDescriptor::TYPE_MESSAGE){
                    auto field = field_def->message_type();
                    if (reverse_refer[field].empty()){
                        desc_queue.push(field);
                        msg_degrees[field] = 0;
                    }
                    int md = reverse_refer[field].size();
                    reverse_refer[field].insert(msg);
                    if (md != (int)reverse_refer[field].size()){
                        ++msg_degrees[msg];//out degree
                    }
                }
            }
        }
        /////////////////////////////////////////////////////////
        while (!msg_degrees.empty()){
            auto it = msg_degrees.begin();
            while (it != msg_degrees.end()){
                if (it->second == 0){
                    break;
                }
                ++it;
            }
            if (it == msg_degrees.end()){
                error_stream << "msg degree not found zero !" << endl;
                throw logic_error("msg degree error !");
            }
            msgs.push_back(it->first);
            for (auto desc : reverse_refer[it->first]){
                if (msg_degrees[desc] > 0){
                    --msg_degrees[desc];
                }
                else {
                    error_stream << "msg type:" << desc->name() << " refer count is 0 !" << endl;
                }
            }
            msg_degrees.erase(it);
        }
    }
};
